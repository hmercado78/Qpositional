# -*- coding: utf-8 -*-
"""
/***************************************************************************
 QpositionalDialog
                                 A QGIS plugin
 assessment the positional quality of geographic data
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2023-05-21
        git sha              : $Format:%H$
        copyright            : (C) 2023 by Harold Mercado Llanos
        email                : hmercado78@hotmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os
from qgis.gui import (QgsFieldComboBox, QgsMapLayerComboBox)
from qgis.PyQt import (uic, QtWidgets)
from PyQt5.QtWidgets import (QFileDialog, QTabWidget, QListWidget, 
    QPushButton, QComboBox, QTextEdit, QGridLayout, QCheckBox, 
    QDialog, QTableWidget, QTableWidgetItem, QAbstractScrollArea, 
    QMessageBox, QInputDialog, QProgressBar, QTextBrowser)
from qgis import processing
from qgis.core import (QgsVectorLayer, QgsFeatureRequest, QgsField, QgsProject, QgsMarkerSymbol, 
    QgsSimpleFillSymbolLayer, QgsSymbolLayer, QgsProperty, QgsFillSymbol, QgsSingleSymbolRenderer, 
    QgsPointXY, QgsFeature, QgsGeometry, QgsCoordinateReferenceSystem, QgsCoordinateTransform)
from processing.tools import dataobjects
from qgis.PyQt.QtCore import QVariant, QPoint, QPointF, QRectF
from qgis.utils import iface
from PyQt5.QtCore import Qt
import math
from PyQt5.QtSvg import QGraphicsSvgItem, QSvgRenderer
from PyQt5.QtWidgets import QGraphicsScene, QGraphicsView
from qgis.PyQt.QtWidgets import QGraphicsLineItem, QGraphicsEllipseItem, QGraphicsSimpleTextItem, QGraphicsRectItem
from qgis.PyQt.QtGui import QPen, QColor, QGradient, QBrush, QRadialGradient
import collections

# Se instancia el proyecto
project = QgsProject.instance()

# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'Qpositional_dialog_base.ui'))


class QpositionalDialog(QtWidgets.QDialog, FORM_CLASS):
    def __init__(self, parent=None):
        """Constructor."""
        super(QpositionalDialog, self).__init__(parent)
        # Set up the user interface from Designer through FORM_CLASS.
        # After self.setupUi() you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://qt-project.org/doc/qt-4.8/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)

        self.Layer_E1.layerChanged.connect(self.SLayer_E1)
        self.Layer_E2.layerChanged.connect(self.SLayer_E2)
        self.Layer_E3.layerChanged.connect(self.SLayer_E3)
        self.Layer_E4.layerChanged.connect(self.SLayer_E4)
        self.Layer_E5.layerChanged.connect(self.SLayer_E5)
        self.Layer_F1.layerChanged.connect(self.SLayer_E1)
        self.Layer_F2.layerChanged.connect(self.SLayer_E2)
        self.Layer_F3.layerChanged.connect(self.SLayer_E3)
        self.Layer_F4.layerChanged.connect(self.SLayer_E4)
        self.Layer_F5.layerChanged.connect(self.SLayer_E5)
        self.Layer_E2.setEnabled(False)
        self.Layer_F2.setEnabled(False)
        self.Layer_E3.setEnabled(False)
        self.Layer_F3.setEnabled(False)
        self.Layer_E4.setEnabled(False)
        self.Layer_F4.setEnabled(False)
        self.Layer_E5.setEnabled(False)
        self.Layer_F5.setEnabled(False)
        self.Boton1.clicked.connect(self.paso2)
        self.Boton2.clicked.connect(self.paso3)
        self.Bt1.clicked.connect(self.cir_unit)
        self.act.clicked.connect(self.cir_unit)
        self.tabWidget.setTabEnabled(1,False)
        self.tabWidget.setTabEnabled(2,False)
        self.circular = QGraphicsScene(self)
        self.grafic.setScene(self.circular)
        self.ringcolour = QColor(153, 153, 255)
        self.ringcolour2 = QColor(250, 169, 62)
        self.anillos.valueChanged[int].connect(self.cir_unit)
        self.section_a.valueChanged[int].connect(self.cir_unit)
        self.cde.currentTextChanged.connect(self.cir_unit)
        self.az_mean_c.stateChanged.connect(self.cir_unit)
        self.des_cir_c.stateChanged.connect(self.cir_unit)
        self.cir_unit_c.clicked.connect(self.cir_unit)
        self.cir_dist_c.clicked.connect(self.cir_unit)
        self.den_gra_c.clicked.connect(self.cir_unit)
        self.Bt1.clicked.connect(self.rest)
        self.Bt1.setEnabled(False)
        self.rem_out.clicked.connect(self.rem_outliers)

        grupo = "Temporal"
        root = project.layerTreeRoot()
        gr_cd = root.addGroup(grupo)
        global migrupo
        migrupo = root.findGroup(grupo) 

    def SLayer_E1(self):
        global cont
        global Layer_E1
        global Layer_F1
        Layer_E1 = self.Layer_E1.currentLayer()
        Layer_F1 = self.Layer_F1.currentLayer()
        if Layer_E1 and Layer_F1 and Layer_E1!=Layer_F1:
            if Layer_E1.geometryType()!=Layer_F1.geometryType():
                if (Layer_E1.geometryType()==0 and Layer_F1.geometryType()==2) or (Layer_E1.geometryType()==2 and Layer_F1.geometryType()==0): 
                    self.adv_1.setText("<font style='color:#297500'><b>Loaded a dataset to Evaluate and a dataset Source</b></font>")
                    self.Boton1.setEnabled(True)
                    self.Layer_E2.setEnabled(True)
                    self.Layer_F2.setEnabled(True)
                    cont=1
                else:    
                    self.adv_1.setText("<font style='color:#FF0000'><b>The geometry types must be the same or (Point-Polyline or Polyline-Point)</b></font>")
                    self.Boton1.setEnabled(False)
            else:
                self.adv_1.setText("<font style='color:#297500'><b>Loaded a dataset to Evaluate and a dataset Source</b></font>")
                self.Boton1.setEnabled(True)
                self.Layer_E2.setEnabled(True)
                self.Layer_F2.setEnabled(True)
                cont=1
        else:
            self.adv_1.setText("<font style='color:#FF0000'><b>A dataset to be evaluated and a dataset source are required</b></font>")
            self.Boton1.setEnabled(False)

    def SLayer_E2(self):
        global cont
        global Layer_E2
        global Layer_F2
        Layer_E2 = self.Layer_E2.currentLayer()
        Layer_F2 = self.Layer_F2.currentLayer()
        if Layer_E2 and Layer_F2 and Layer_E2!=Layer_F2:
            if Layer_E2.geometryType()!=Layer_F2.geometryType():
                if (Layer_E2.geometryType()==0 and Layer_F2.geometryType()==2) or (Layer_E2.geometryType()==2 and Layer_F2.geometryType()==0): 
                    self.adv_1.setText("<font style='color:#297500'><b>Loaded a dataset to Evaluate and a dataset Source</b></font>")
                    self.Boton1.setEnabled(True)
                    self.Layer_E3.setEnabled(True)
                    self.Layer_F3.setEnabled(True)
                    cont=2
                else:    
                    self.adv_1.setText("<font style='color:#FF0000'><b>The geometry types must be the same or (Point-Polyline or Polyline-Point)</b></font>")
                    self.Boton1.setEnabled(False)
            else:
                self.adv_1.setText("<font style='color:#297500'><b>Loaded a dataset to Evaluate and a dataset Source</b></font>")
                self.Boton1.setEnabled(True)
                self.Layer_E3.setEnabled(True)
                self.Layer_F3.setEnabled(True)
                cont=2
        else:
            self.adv_1.setText("<font style='color:#FF0000'><b>A dataset to be evaluated and a dataset source are required</b></font>")
            self.Boton1.setEnabled(False)

    def SLayer_E3(self):
        global cont
        global Layer_E3
        global Layer_F3
        Layer_E3 = self.Layer_E3.currentLayer()
        Layer_F3 = self.Layer_F3.currentLayer()
        if Layer_E3 and Layer_F3 and Layer_E3!=Layer_F3:
            if Layer_E3.geometryType()!=Layer_F3.geometryType():
                if (Layer_E3.geometryType()==0 and Layer_F3.geometryType()==2) or (Layer_E3.geometryType()==2 and Layer_F3.geometryType()==0): 
                    self.adv_1.setText("<font style='color:#297500'><b>Loaded a dataset to Evaluate and a dataset Source</b></font>")
                    self.Boton1.setEnabled(True)
                    self.Layer_E4.setEnabled(True)
                    self.Layer_F4.setEnabled(True)
                    cont=3
                else:
                    self.adv_1.setText("<font style='color:#FF0000'><b>The geometry types must be the same or (Point-Polyline or Polyline-Point)</b></font>")
                    self.Boton1.setEnabled(False)
            else:
                self.adv_1.setText("<font style='color:#297500'><b>Loaded a dataset to Evaluate and a dataset Source</b></font>")
                self.Boton1.setEnabled(True)
                self.Layer_E4.setEnabled(True)
                self.Layer_F4.setEnabled(True)
                cont=3
        else:
            self.adv_1.setText("<font style='color:#FF0000'><b>A dataset to be evaluated and a dataset source are required</b></font>")
            self.Boton1.setEnabled(False)

    def SLayer_E4(self):
        global cont
        global Layer_E4
        global Layer_F4
        Layer_E4 = self.Layer_E4.currentLayer()
        Layer_F4 = self.Layer_F4.currentLayer()
        if Layer_E4 and Layer_F4 and Layer_E4!=Layer_F4:
            if Layer_E4.geometryType()!=Layer_F4.geometryType():
                if (Layer_E4.geometryType()==0 and Layer_F4.geometryType()==2) or (Layer_E4.geometryType()==2 and Layer_F4.geometryType()==0): 
                    self.adv_1.setText("<font style='color:#297500'><b>Loaded a dataset to Evaluate and a dataset Source</b></font>")
                    self.Boton1.setEnabled(True)
                    self.Layer_E5.setEnabled(True)
                    self.Layer_F5.setEnabled(True)
                    cont=4
                else:
                    self.adv_1.setText("<font style='color:#FF0000'><b>The geometry types must be the same or (Point-Polyline or Polyline-Point)</b></font>")
                    self.Boton1.setEnabled(False)
            else:
                self.adv_1.setText("<font style='color:#297500'><b>Loaded a dataset to Evaluate and a dataset Source</b></font>")
                self.Boton1.setEnabled(True)
                self.Layer_E5.setEnabled(True)
                self.Layer_F5.setEnabled(True)
                cont=4
        else:
            self.adv_1.setText("<font style='color:#FF0000'><b>A dataset to be evaluated and a dataset source are required</b></font>")
            self.Boton1.setEnabled(False)

    def SLayer_E5(self):
        global cont
        global Layer_E5
        global Layer_F5
        Layer_E5 = self.Layer_E5.currentLayer()
        Layer_F5 = self.Layer_F5.currentLayer()
        if Layer_E5 and Layer_F5  and Layer_E5!=Layer_F5:
            if Layer_E5.geometryType()!=Layer_F5.geometryType():
                if (Layer_E5.geometryType()==0 and Layer_F5.geometryType()==2) or (Layer_E5.geometryType()==2 and Layer_F5.geometryType()==0): 
                    self.adv_1.setText("<font style='color:#297500'><b>Loaded a dataset to Evaluate and a dataset Source</b></font>")
                    self.Boton1.setEnabled(True)
                    cont=5
                else:
                    self.adv_1.setText("<font style='color:#FF0000'><b>The geometry types must be the same or (Point-Polyline or Polyline-Point)</b></font>")
                    self.Boton1.setEnabled(False)
            else:
                self.adv_1.setText("<font style='color:#297500'><b>Loaded a dataset to Evaluate and a dataset Source</b></font>")
                self.Boton1.setEnabled(True)
                cont=5
        else:
            self.adv_1.setText("<font style='color:#FF0000'><b>A dataset to be evaluated and a dataset source are required</b></font>")
            self.Boton1.setEnabled(False)

    # Se crea la lista de capas, se crea el area de cobertura comun y se verifican los conjuntos de datos
    def paso2(self):
        global Layer_E
        Layer_E = list()
        global Layer_F
        Layer_F = list()
        global entid
        entid=list()
        global inter_cd

        self.tabWidget.setTabEnabled(1,True)
        self.tabWidget.setCurrentIndex(1)
        if cont==1:
            Layer_E=[Layer_E1]
            Layer_F=[Layer_F1]
        if cont==2:
            Layer_E=[Layer_E1,Layer_E2]
            Layer_F=[Layer_F1,Layer_F2]
        if cont==3:
            Layer_E=[Layer_E1,Layer_E2,Layer_E3]
            Layer_F=[Layer_F1,Layer_F2,Layer_F3]
        if cont==4:
            Layer_E=[Layer_E1,Layer_E2,Layer_E3,Layer_E4]
            Layer_F=[Layer_F1,Layer_F2,Layer_F3,Layer_F4]
        if cont==5:
            Layer_E=[Layer_E1,Layer_E2,Layer_E3,Layer_E4,Layer_E5]
            Layer_F=[Layer_E1,Layer_E2,Layer_E3,Layer_E4,Layer_E5]
                
        n=0
        entid.clear()
        while n<=(cont-1):
            cant=0
            for feat in Layer_E[n].getFeatures():
                cant +=1
            entid.append(cant)
            n += 1

        self.Tab_ver.clear()
        self.Tab_ver.setRowCount(cont)
        self.Tab_ver.setColumnCount(4)            
        self.Tab_ver.setHorizontalHeaderItem(0, QTableWidgetItem("Dataset Evaluated"))
        self.Tab_ver.setHorizontalHeaderItem(1, QTableWidgetItem("Features"))
        self.Tab_ver.setHorizontalHeaderItem(2, QTableWidgetItem("Dataset Source"))
        self.Tab_ver.setHorizontalHeaderItem(3, QTableWidgetItem("Extent"))

        Tab_ver = QTableWidget()
        self.Tab_ver.setSizeAdjustPolicy(QAbstractScrollArea.AdjustToContents)

        fila = 0
        for registro in Layer_E:
            celda1 = QTableWidgetItem(registro.name())
            celda2 = QTableWidgetItem(str(entid[fila]))
            celda3 = QTableWidgetItem(Layer_F[fila].name())
            self.Tab_ver.setItem(fila,0,celda1)
            self.Tab_ver.setItem(fila,1,celda2)
            self.Tab_ver.setItem(fila,2,celda3)
            fila +=1 

        #Genera la extension con la cobertura de los CDE
        i = 0
        inter_cd=list()
        inter_cd.clear()
        xmin=list()
        ymin=list()
        xmax=list()
        ymax=list()
        xmin.clear()
        ymin.clear()
        xmax.clear()
        ymax.clear()
        cdr_reproy=list()
        cdr_reproy.clear()
        fallo=list()
        fallo.clear()
        for i in range((len(Layer_E))):
            # En caso que se requiera se reproyecta el CDR
            if Layer_E[i].crs().description()!=Layer_F[i].crs().description():
                c_cde = Layer_E[i].crs().authid()
                ver_cde = QgsCoordinateReferenceSystem(c_cde)
                cdr_rep=processing.run("native:reprojectlayer", {'INPUT':Layer_F[i],'TARGET_CRS':ver_cde,'OUTPUT':'TEMPORARY_OUTPUT'})
                name_l=str(Layer_F[i].name())+"_Reproy"
                ren=processing.run("native:renamelayer", {'INPUT': cdr_rep["OUTPUT"],'NAME': name_l})
                project.addMapLayer(cdr_rep["OUTPUT"], False)
                migrupo.addLayer(cdr_rep["OUTPUT"])
                cdr_reproy.append(Layer_F[i].name)
                Layer_F[i]=ren["OUTPUT"]

            exten_cde = processing.run("native:polygonfromlayerextent", {'INPUT': Layer_E[i],'ROUND_TO':0,'OUTPUT':'TEMPORARY_OUTPUT'})
            project.addMapLayer(exten_cde["OUTPUT"], True)

            exten_cdr = processing.run("native:polygonfromlayerextent", {'INPUT': Layer_F[i],'ROUND_TO':0,'OUTPUT':'TEMPORARY_OUTPUT'})
            project.addMapLayer(exten_cdr["OUTPUT"], True)

            #Genera la intersection para verificar la cobertura comun
            inter_ef = processing.run("native:intersection", {'INPUT': exten_cde["OUTPUT"], 'OVERLAY': exten_cdr["OUTPUT"], 'OUTPUT':'TEMPORARY_OUTPUT'})            
            project.addMapLayer(inter_ef["OUTPUT"], True)
            project.removeMapLayer(exten_cdr["OUTPUT"].id())

            area_int=0
            for feature_e in exten_cde["OUTPUT"].getFeatures():
                geom_e = feature_e.geometry()
                area_cde = (geom_e.area()) 
            project.removeMapLayer(exten_cde["OUTPUT"].id()) 

            if len(inter_ef["OUTPUT"])>0:
                inter = processing.run("native:polygonfromlayerextent", {'INPUT': inter_ef["OUTPUT"],'ROUND_TO':0,'OUTPUT':'TEMPORARY_OUTPUT'})
                project.addMapLayer(inter["OUTPUT"], True)
                project.removeMapLayer(inter_ef["OUTPUT"].id()) 

                for feature_i in inter["OUTPUT"].getFeatures():
                    geom_i = feature_i.geometry()
                    area_int = (geom_i.area()) 
                    attrs = feature_i.attributes()
                    xmin.append(attrs[0])
                    ymin.append(attrs[1])
                    xmax.append(attrs[2])
                    ymax.append(attrs[3])

                celda4= QTableWidgetItem(str('{:,.2f}'.format(100*area_int/area_cde)) + "%")
                self.Tab_ver.setItem(i,3,celda4)
                if (100*(area_int/area_cde))>10:
                    fallo.append("n")
                else:
                    fallo.append("s")
                project.removeMapLayer(inter["OUTPUT"].id()) 
            else: 
                celda4= QTableWidgetItem("There is no common coverage area")
                self.Tab_ver.setItem(i,3,celda4)
                fallo.append("s")
                xmin.append(0)
                ymin.append(0)
                xmax.append(0)
                ymax.append(0)

        x_min = min(xmin)
        y_min = min(ymin)
        x_max = max(xmax)
        y_max = max(ymax)

        epsg=Layer_E[0].crs().toWkt()
        #Crear un layer memory
        exten = QgsVectorLayer("Polygon?crs="+ epsg, "temp", "Memory")
        exten.startEditing()
        points = [[QgsPointXY(x_min,y_min),QgsPointXY(x_min,y_max),QgsPointXY(x_max,y_max),QgsPointXY(x_max,y_min),QgsPointXY(x_min,y_min)]]
        #Set feature
        feature = QgsFeature()
        #Set geometry
        feature.setGeometry(QgsGeometry.fromPolygonXY(points))
        #Area determination (remember: projection is not in meters)
        geom = feature.geometry()
        area= geom.area()
        #set attributes values 
        feature.setAttributes([1, area])
     
        exten.dataProvider().addFeature(feature)
        #stop editing and save changes
        exten.commitChanges()

        # estilo para el poligono de la cobertura
        fill = QgsSimpleFillSymbolLayer()
        fill.setStrokeColor(Qt.red)
        fill.setStrokeWidth(0.5)
        fill.setColor(Qt.transparent)            
        symbol = QgsFillSymbol()
        symbol.changeSymbolLayer(0, fill)
        exten.setRenderer(QgsSingleSymbolRenderer(symbol))
        ren_ext=processing.run("native:renamelayer", {'INPUT': exten,'NAME': 'Assessment Coverage'})
        project.addMapLayer(ren_ext["OUTPUT"], False)
        migrupo.addLayer(ren_ext["OUTPUT"])

        area_int=0
        features = exten.getFeatures()
        for feature in features:
            geom = feature.geometry()
            area_int = (geom.area()) 
        celda5= ("Assessment Coverage:" + str('{:,.2f}'.format(100*area_int/area_cde)) + "%")

        i=0
        for i in range((len(inter_cd)-1)):
            project.removeMapLayer(inter_cd[i].id()) 

        exten.selectAll()
        iface.mapCanvas().zoomToSelected(exten)
        canvas = iface.mapCanvas()
        canvas.zoomOut()
        exten.removeSelection() 
        global ext
        ext=exten
        
        self.Boton2.setEnabled(True)
        self.Boton2.setText("Next")
        for x in fallo:
            if x=="s":
                self.Boton2.setEnabled(False)
                self.Boton2.setText("Warning: Reselect data sets to be evaluate")

        self.Bt1.setEnabled(True)

    #Genera los vectores de error, mediante shortestline, genera las estadisticas circulares y los diagramas
    def paso3(self):
        self.tabWidget.setTabEnabled(2,True)
        self.tabWidget.setCurrentIndex(2)
        global dist
        global x
        
        global nom_cde
        nom_cde=list()
        nom_cde.clear()
        nom_cde.append("All")
        # Se configura el contexto para utilziarlo en los geoprocesos que requieran trabajar con geometrias invalidas
        context = dataobjects.createContext()
        context.setInvalidGeometryCheck(QgsFeatureRequest.GeometryNoCheck)

        x=0
        for x in range((len(Layer_E))):
            if Layer_E[x].geometryType()==0: # si la capa es  ######## PUNTO ######
                Layer_E[x].removeSelection()
                sel = processing.run("native:selectbylocation", {'INPUT':Layer_E[x],'PREDICATE':[6],'INTERSECT':ext,'METHOD':0})

                if Layer_F[x].geometryType()==0: # si la capa de referencia es  ######## PUNTO ######
                    dist = processing.run("native:shortestline", {'SOURCE':sel['OUTPUT'],'DESTINATION':Layer_F[x],'METHOD':0,'NEIGHBORS':1,'DISTANCE':None,'OUTPUT':'TEMPORARY_OUTPUT'})
                    project.addMapLayer(dist['OUTPUT'], False)
                    migrupo.addLayer(dist['OUTPUT'])
                    Layer_E[x].removeSelection()
                    self.dist_Az()

                if Layer_F[x].geometryType()==2: # si la capa de referencia es  ######## POLIGONO ######
                    cen_f = processing.run("native:centroids", {'INPUT':Layer_F[x],'ALL_PARTS':False,'OUTPUT':'TEMPORARY_OUTPUT'}, context=context)                 
                    project.addMapLayer(cen_f['OUTPUT'], True)
              
                    dist = processing.run("native:shortestline", {'SOURCE':sel['OUTPUT'],'DESTINATION':cen_f['OUTPUT'],'METHOD':0,'NEIGHBORS':1,'DISTANCE':None,'OUTPUT':'TEMPORARY_OUTPUT'})
                    project.addMapLayer(dist['OUTPUT'], False)
                    migrupo.addLayer(dist['OUTPUT'])
                    Layer_E[x].removeSelection()
                    project.removeMapLayer(cen_f['OUTPUT'].id()) 
                    self.dist_Az()


            if Layer_E[x].geometryType()==1: # si la capa es  ######## LINEA ######
                Layer_E[x].removeSelection()
                ver = processing.run("native:extractvertices", {'INPUT':Layer_E[x],'OUTPUT':'TEMPORARY_OUTPUT'}, context=context)
                project.addMapLayer(ver['OUTPUT'], True)

                sel = processing.run("native:selectbylocation", {'INPUT':ver['OUTPUT'],'PREDICATE':[6],'INTERSECT':ext,'METHOD':0})

                dist = processing.run("native:shortestline", {'SOURCE':sel['OUTPUT'],'DESTINATION':Layer_F[x],'METHOD':0,'NEIGHBORS':1,'DISTANCE':None,'OUTPUT':'TEMPORARY_OUTPUT'})
                project.addMapLayer(dist['OUTPUT'], False)
                migrupo.addLayer(dist['OUTPUT'])
                Layer_E[x].removeSelection()
                project.removeMapLayer(ver['OUTPUT'].id())
                self.dist_Az()
                    
            if Layer_E[x].geometryType()==2: # si la capa es  ######## POLIGONO ######
                Layer_E[x].removeSelection()
                cen = processing.run("native:centroids", {'INPUT':Layer_E[x],'ALL_PARTS':False,'OUTPUT':'TEMPORARY_OUTPUT'}, context=context)                 
                project.addMapLayer(cen['OUTPUT'], True)

                sel=processing.run("native:selectbylocation", {'INPUT':cen['OUTPUT'],'PREDICATE':[6],'INTERSECT':ext,'METHOD':0})

                if Layer_F[x].geometryType()==0: # si la capa de referencia es  ######## PUNTO ######
                    dist = processing.run("native:shortestline", {'SOURCE':sel['OUTPUT'],'DESTINATION':Layer_F[x],'METHOD':0,'NEIGHBORS':1,'DISTANCE':None,'OUTPUT':'TEMPORARY_OUTPUT'})
                    project.addMapLayer(dist['OUTPUT'], False)
                    migrupo.addLayer(dist['OUTPUT'])
                    Layer_E[x].removeSelection()
                    project.removeMapLayer(cen['OUTPUT'].id())                    
                    self.dist_Az()

                if Layer_F[x].geometryType()==2: # si la capa de referencia es  ######## POLIGONO ######
                    cen_f = processing.run("native:centroids", {'INPUT':Layer_F[x],'ALL_PARTS':False,'OUTPUT':'TEMPORARY_OUTPUT'}, context=context)                 
                    project.addMapLayer(cen_f['OUTPUT'], True)
                    dist = processing.run("native:shortestline", {'SOURCE':sel['OUTPUT'],'DESTINATION':cen_f['OUTPUT'],'METHOD':0,'NEIGHBORS':1,'DISTANCE':None,'OUTPUT':'TEMPORARY_OUTPUT'})
                    project.addMapLayer(dist['OUTPUT'], False)
                    migrupo.addLayer(dist['OUTPUT'])
                    Layer_E[x].removeSelection()                    
                    project.removeMapLayer(cen['OUTPUT'].id())
                    project.removeMapLayer(cen_f['OUTPUT'].id())
                    self.dist_Az()
        self.cde.addItems(list(nom_cde))

        self.cir_unit()

    # calculo de la distancia y azimut
    def dist_Az(self):
        conteo=dist["OUTPUT"].fields().count() # Contar el numero de campos
        campos=list(range(conteo))
        dist["OUTPUT"].dataProvider().deleteAttributes(campos)
        dist["OUTPUT"].dataProvider().addAttributes([QgsField("Distance", QVariant.Double)])
        dist["OUTPUT"].updateFields()
        dist["OUTPUT"].startEditing()
        for n in  dist['OUTPUT'].getFeatures():
            longi=n.geometry().distanceToVertex(1)
            n.setAttribute(0,longi)
            dist["OUTPUT"].updateFeature(n)
        dist["OUTPUT"].dataProvider().addAttributes([QgsField("Azimuth", QVariant.Double)])
        dist["OUTPUT"].updateFields()
        for n in  dist['OUTPUT'].getFeatures():
            xm = n.geometry().vertexAt(0).x()
            ym = n.geometry().vertexAt(0).y()
            xt = n.geometry().vertexAt(1).x()
            yt = n.geometry().vertexAt(1).y()
            delta_n = (yt-ym)
            delta_e = (xt-xm)
            if delta_n==0 or delta_e==0:
                if delta_n==0:
                    if delta_e>0:
                        azimut = 90
                    else:
                        azimut = 270
                else:
                    if delta_n>0:
                        azimut = 0
                    else:
                        azimut = 180
            else:    
                if delta_n>0 and delta_e>0:
                    azimut = (math.atan(delta_e/delta_n))*(180/math.pi)
                if delta_n<0 and delta_e>0:
                    azimut = 180+((math.atan(delta_e/delta_n))*(180/math.pi))
                if delta_n<0 and delta_e<0:
                    azimut = 180+((math.atan(delta_e/delta_n))*(180/math.pi))
                if delta_n>0 and delta_e<0:
                    azimut = 360+((math.atan(delta_e/delta_n))*(180/math.pi))
            n.setAttribute(1,azimut)
            dist["OUTPUT"].updateFeature(n)                   
        dist["OUTPUT"].commitChanges()
        nombre = "Error vectors " + (str(x+1))
        processing.run("native:renamelayer", {'INPUT': dist["OUTPUT"],'NAME': nombre})
        nom_cde.append(nombre)

    def cir_unit(self):
        self.tabWidget.setTabEnabled(2,True)
        self.tabWidget.setCurrentIndex(2)

        self.circular.clear()
        
        viewprect = QRectF(self.grafic.viewport().rect())
        global ventana
        ventana=viewprect
        self.grafic.setSceneRect(viewprect)

        left = self.grafic.sceneRect().left()
        right = self.grafic.sceneRect().right()
        width = right - left
        top = self.grafic.sceneRect().top()
        bottom = self.grafic.sceneRect().bottom()
        height = bottom - top

        numrings=self.anillos.value()

        size = width
        if width > height:
            size = height
        padding = 15
        maxlength = (size / 2) - padding * 2
        center = QPoint(int(left + (width / 2)),int(top + (height / 2)))
        # The scene geomatry of the center point
        start = QPointF(self.grafic.mapToScene(center))

        if self.cir_unit_c.isChecked() or self.cir_dist_c.isChecked():
            #Dibuja los anillos o rings
            for i in range(numrings):
                step = maxlength / numrings
                radius = step * (i + 1)
                circle = QGraphicsEllipseItem(start.x() - radius,start.y() - radius,radius * 2,radius * 2)
                circle.setPen(QPen(self.ringcolour))
                self.circular.addItem(circle)

        if self.den_gra_c.isChecked():
            radius = maxlength
            rect = QGraphicsRectItem(start.x() - radius,start.y() - radius,radius * 2,radius * 2)
            grad = QRadialGradient(start.x(), start.y(), radius)
            pt_colour1 = QColor(255, 0, 0)
            pt_colour1.setAlphaF(0.8)
            pt_colour2 = QColor(0, 46, 255)
            pt_colour2.setAlphaF(0.8)
            grad.setColorAt(0, pt_colour1)
            grad.setColorAt(1, pt_colour2)
            brush = QBrush(grad)
            rect.setBrush(brush)
            self.circular.addItem(rect)

            linea_deg = QGraphicsLineItem(start.x()-radius, start.y(), start.x()+radius, start.y())            
            deg_medcolour2 = QColor(197, 197, 197)
            myPen2 = QPen(deg_medcolour2)
            myPen2.setWidth(1)
            myPen2.setCapStyle(Qt.FlatCap)
            linea_deg.setPen(myPen2)
            self.circular.addItem(linea_deg)

            linea_deg = QGraphicsLineItem(start.x(), start.y()-radius, start.x(), start.y() +radius)            
            deg_medcolour2 = QColor(197, 197, 197)
            myPen2 = QPen(deg_medcolour2)
            myPen2.setWidth(1)
            myPen2.setCapStyle(Qt.FlatCap)
            linea_deg.setPen(myPen2)
            self.circular.addItem(linea_deg)

        act_cde = self.cde.currentText()

        list_aci = list()
        list_aci.clear()
        c=dict()
        global lista_cde

        if act_cde=="All":
            lista_cde = nom_cde
            if lista_cde[0]=="All":
                lista_cde.remove("All")

            max_total=0
            j=0
            for j in range(len(lista_cde)):
                cd_selec = project.mapLayersByName(lista_cde[j])[0]
                maxi_dist = cd_selec.maximumValue(0)
                if maxi_dist>max_total:
                    max_total=maxi_dist

            global az_med
            sen_az_t=0
            cos_az_t=0
            sen_az_t2=0
            cos_az_t2=0
            datos=0
            sum_dist = 0

            lon_max=0
            lon_feat_max=0        
            for j in range(len(lista_cde)):
                cd_selec = project.mapLayersByName(lista_cde[j])[0]
                for i in cd_selec.getFeatures():
                    if self.cir_unit_c.isChecked():
                        attrs=i.attributes()
                        lon_feat = attrs[0]
                        azim_feat = attrs[1]
                        azim_feat_e = round(azim_feat,0)
                        c.clear()
                        c = collections.Counter(list_aci)
                        veces=c[azim_feat_e]
                        list_aci.append(azim_feat_e)    

                        lon = radius-(veces/0.5)
                        if lon<0:
                            lon=0
                        pos_y = (math.cos(azim_feat_e*math.pi/180))*lon
                        pos_x = (math.sin(azim_feat_e*math.pi/180))*lon
                        rel=100
                        punto = QGraphicsEllipseItem(start.x()+pos_x-((radius/rel)/2), start.y()-pos_y-((radius/rel)/2),radius/rel, radius/rel)
                        pt_colour = QColor(255, 0, 0)
                        myPen = QPen(pt_colour)
                        myPen.setWidth(2)
                        myPen.setCapStyle(Qt.FlatCap)
                        punto.setPen(myPen)
                        brush = QBrush(QColor(pt_colour), style=Qt.SolidPattern)
                        punto.setBrush(brush)
                        self.circular.addItem(punto)

                    if self.cir_dist_c.isChecked():
                        attrs=i.attributes()
                        lon_feat = attrs[0]
                        azim_feat = attrs[1]
                        lon = lon_feat*(radius/max_total)
                        if lon_max<lon:
                            lon_max=lon
                            lon_feat_max=lon_feat
                        pos_y = (math.cos(azim_feat*math.pi/180))*lon
                        pos_x = (math.sin(azim_feat*math.pi/180))*lon
                        linea = QGraphicsLineItem(start.x(), start.y(), start.x()+pos_x, start.y()-pos_y)
                        ln_medcolour = QColor(0, 0, 0)
                        myPen = QPen(ln_medcolour)
                        myPen.setWidth(2)
                        myPen.setCapStyle(Qt.FlatCap)
                        linea.setPen(myPen)
                        self.circular.addItem(linea)

                    if self.den_gra_c.isChecked():
                        attrs=i.attributes()
                        lon_feat = attrs[0]
                        azim_feat = attrs[1]
                        lon = lon_feat*(radius/max_total)
                        if lon_max<lon:
                            lon_max=lon
                            lon_feat_max=lon_feat
                        pos_y = (math.cos(azim_feat*math.pi/180))*lon
                        pos_x = (math.sin(azim_feat*math.pi/180))*lon
                        rel=100
                        punto = QGraphicsEllipseItem(start.x()+pos_x, start.y()-pos_y,radius/rel, radius/rel)
                        pt_colour = QColor(0, 0, 0)
                        myPen = QPen(pt_colour)
                        myPen.setWidth(2)
                        myPen.setCapStyle(Qt.FlatCap)
                        punto.setPen(myPen)
                        brush = QBrush(QColor(pt_colour), style=Qt.SolidPattern)
                        punto.setBrush(brush)
                        self.circular.addItem(punto)

                    datos +=1
                    sum_dist += lon_feat
                    
                    # Calculo del acimut medio
                    cos_az = (math.cos(azim_feat*math.pi/180))
                    sen_az = (math.sin(azim_feat*math.pi/180))
                    sen_az_t = sen_az_t + sen_az
                    cos_az_t = cos_az_t + cos_az

                    #Calculo del Coseno doble y del Seno doble
                    cos_az2 = (math.cos(2*azim_feat*math.pi/180))
                    sen_az2 = (math.sin(2*azim_feat*math.pi/180))
                    sen_az_t2 = sen_az_t2 + sen_az2
                    cos_az_t2 = cos_az_t2 + cos_az2

            #calculo del acimut medio        
            az_med = math.atan(sen_az_t/cos_az_t)
            self.num_d.setText("Num data: "+str(datos))

            #Calculo del acimut medio doble 
            az_med2 = math.atan(sen_az_t2/cos_az_t2)

        else:
            cd_selec = project.mapLayersByName(str(act_cde))[0]
            max_total = cd_selec.maximumValue(0)

            sen_az_t=0
            cos_az_t=0
            sen_az_t2=0
            cos_az_t2=0
            datos=0
            sum_dist=0
            lon_max=0
            lon_feat_max=0
            for i in cd_selec.getFeatures():
                if len(cd_selec)>0:
                    if self.cir_unit_c.isChecked():
                        attrs=i.attributes()
                        lon_feat = attrs[0]
                        azim_feat = attrs[1]
                        azim_feat_e = round(azim_feat,0)
                        c.clear()
                        c = collections.Counter(list_aci)
                        veces=c[azim_feat_e]
                        list_aci.append(azim_feat_e)    

                        lon = radius-(veces/0.5)
                        if lon<0:
                            lon=0
                        pos_y = (math.cos(azim_feat_e*math.pi/180))*lon
                        pos_x = (math.sin(azim_feat_e*math.pi/180))*lon
                        rel=100
                        punto = QGraphicsEllipseItem(start.x()+pos_x-((radius/rel)/2), start.y()-pos_y-((radius/rel)/2),radius/rel, radius/rel)
                        pt_colour = QColor(255, 0, 0)
                        myPen = QPen(pt_colour)
                        myPen.setWidth(2)
                        myPen.setCapStyle(Qt.FlatCap)
                        punto.setPen(myPen)
                        brush = QBrush(QColor(pt_colour), style=Qt.SolidPattern)
                        punto.setBrush(brush)
                        self.circular.addItem(punto)

                    if self.cir_dist_c.isChecked():
                        attrs=i.attributes()
                        lon_feat = attrs[0]
                        azim_feat = attrs[1]
                        lon = lon_feat*(radius/max_total)
                        if lon_max<lon:
                            lon_max=lon
                            lon_feat_max=lon_feat
                        pos_y = (math.cos(azim_feat*math.pi/180))*lon
                        pos_x = (math.sin(azim_feat*math.pi/180))*lon
                        linea = QGraphicsLineItem(start.x(), start.y(), start.x()+pos_x, start.y()-pos_y)
                        ln_medcolour = QColor(0, 0, 0)
                        myPen = QPen(ln_medcolour)
                        myPen.setWidth(2)
                        myPen.setCapStyle(Qt.FlatCap)
                        linea.setPen(myPen)
                        self.circular.addItem(linea)

                    if self.den_gra_c.isChecked():
                        attrs=i.attributes()
                        lon_feat = attrs[0]
                        azim_feat = attrs[1]
                        lon = lon_feat*(radius/max_total)
                        if lon_max<lon:
                            lon_max=lon
                            lon_feat_max=lon_feat
                        pos_y = (math.cos(azim_feat*math.pi/180))*lon
                        pos_x = (math.sin(azim_feat*math.pi/180))*lon
                        rel=100
                        punto = QGraphicsEllipseItem(start.x()+pos_x, start.y()-pos_y,radius/rel, radius/rel)
                        pt_colour = QColor(0, 0, 0)
                        myPen = QPen(pt_colour)
                        myPen.setWidth(2)
                        myPen.setCapStyle(Qt.FlatCap)
                        punto.setPen(myPen)
                        brush = QBrush(QColor(pt_colour), style=Qt.SolidPattern)
                        punto.setBrush(brush)
                        self.circular.addItem(punto)

                    datos +=1
                    sum_dist += lon_feat   

                    # Calculo del acimut medio
                    cos_az = (math.cos(azim_feat*math.pi/180))
                    sen_az = (math.sin(azim_feat*math.pi/180))
                    sen_az_t = sen_az_t + sen_az
                    cos_az_t = cos_az_t + cos_az

                    # Calculo del acimut medio doble
                    cos_az2 = (math.cos(2*azim_feat*math.pi/180))
                    sen_az2 = (math.sin(2*azim_feat*math.pi/180))
                    sen_az_t2 = sen_az_t2 + sen_az2
                    cos_az_t2 = cos_az_t2 + cos_az2
                else:
                    datos=0
                    self.rem_out.setEnabled(False)

            # Calculo del azimut medio
            if datos!=0:    
                az_med = math.atan(sen_az_t/cos_az_t)
            else:
                az_med=""
            self.num_d.setText("Num data: "+str(datos))

            #Calculo del acimut medio doble 
            if datos!=0:
                az_med2 = math.atan(sen_az_t2/cos_az_t2)
            else:
                az_med2=""

        if datos!=0: 
            # Dibuja el azimut en el circulo unitario
            az_med_t = az_med*(180/math.pi)

            if cos_az_t==0 or sen_az_t==0:
                if cos_az_t==0:
                    if sen_az_t>0:
                        az_med_t = 90
                    else:
                        az_med_t = 270
                else:
                    if cos_az_t>0:
                        az_med_t = 0
                    else:
                        az_med_t = 180
            else:    
                if cos_az_t>0 and sen_az_t>0:
                    az_med_t = az_med_t
                if cos_az_t<0 and sen_az_t>0:
                    az_med_t = 180+az_med_t
                if cos_az_t<0 and sen_az_t<0:
                    az_med_t = 180+az_med_t
                if cos_az_t>0 and sen_az_t<0:
                    az_med_t = 360+az_med_t

            if self.cir_unit_c.isChecked():
                lon_max=radius
                
            pos_y = (math.cos(az_med_t*math.pi/180))*lon_max
            pos_x = (math.sin(az_med_t*math.pi/180))*lon_max
            
            linea_az = QGraphicsLineItem(start.x(), start.y(), start.x()+pos_x, start.y()-pos_y)
            az_medcolour = QColor(255, 0, 0)
            myPen = QPen(az_medcolour)
            myPen.setWidth(2)
            myPen.setCapStyle(Qt.FlatCap)
            linea_az.setPen(myPen)


            if self.az_mean_c.checkState():
                self.circular.addItem(linea_az)

            if datos==0:
                grados,minutos,segundos=""

            minutos, grados = math.modf(az_med_t)
            segundos, minutos = math.modf(minutos*60)
            segundos = (segundos*60)
            resul_1 = f"Mean azimuth: <b>{grados:.0f}° {minutos:.0f}' {segundos:.2f}''</b><p>"
            self.az_mean_t.setText(resul_1)
            if self.cir_unit_c.isChecked():
                self.long_a.setText("Rings: "+str(round((1)/numrings,2)))
            else:
                self.long_a.setText("Rings: "+str(round((lon_feat_max)/numrings,2)))

            # Modulo medio
            mod_med = (((cos_az_t**2)+(sen_az_t**2))**0.5)/datos
            resul_2 = f"Mean module: <b>{mod_med:.2f}</b><p>"
            self.mod_med_t.setText(resul_2)

            # Modulo medio doble
            mod_med2 = (((cos_az_t2**2)+(sen_az_t2**2))**0.5)/datos


            # Varianza circular
            var_cir = 1 - mod_med
            resul_3 = f"Circular Variance: <b>{var_cir:.2f}</b><p>"
            self.var_cir_t.setText(resul_3)

            # Desviacion estandar circular
            des_cir = ((-2*(math.log(1-var_cir))))**0.5
            minutos, grados = math.modf(des_cir)
            segundos, minutos = math.modf(minutos*60)
            segundos = (segundos*60)
            resul_4 = f"Circular Standard Deviation (Degree):<br> <b>{grados:.0f}° {minutos:.0f}' {segundos:.2f}''</b><p>"
            self.des_cir_t.setText(resul_4)

            # Dibujar la desviacion estandar
            az_med_i=az_med_t-des_cir
            if az_med_i<0:
                az_med_i=360+az_med_i
            az_med_s=az_med_t+des_cir
            if az_med_s>360:
                az_med_s=az_med_s-360

            #Para dibujar las desviaciones estandar con tipo linea
            #pos_y_i = (math.cos(az_med_i*math.pi/180))*lon_max
            #pos_x_i = (math.sin(az_med_i*math.pi/180))*lon_max
            #pos_y_s = (math.cos(az_med_s*math.pi/180))*lon_max
            #pos_x_s = (math.sin(az_med_s*math.pi/180))*lon_max
            #linea_az_i = QGraphicsLineItem(start.x(), start.y(), start.x()+pos_x_i, start.y()-pos_y_i)
            #linea_az_s = QGraphicsLineItem(start.x(), start.y(), start.x()+pos_x_s, start.y()-pos_y_s)
            #linea_az_i.setPen(myPen)
            #linea_az_s.setPen(myPen)
            #self.circular.addItem(linea_az_i)
            #self.circular.addItem(linea_az_s)
            #-----

            #Dibujar la la desviacion estandar circular como un PIE.
            if self.des_cir_c.isChecked():       
                circle2 = QGraphicsEllipseItem(start.x() - radius,start.y() - radius,radius * 2,radius * 2)
                circle2.setStartAngle(int((360-az_med_i+90-(des_cir*2))*16))
                circle2.setSpanAngle(int((des_cir*2)*16))   
                circle2.setPen(QPen(self.ringcolour2))
                self.ringcolour2.setAlphaF(0.3)
                circle2.setBrush((self.ringcolour2))
                self.circular.addItem(circle2)

                
            # Estimar el parámetro de concentración para una distriubción von Mises
            if mod_med<0.53:
                k = (2*mod_med)+(mod_med**3)+((5/6)*mod_med**5)
            if mod_med>=0.53 and mod_med<0.85:
                k = (-0.4)+(1.39*mod_med)+(0.43/(1-mod_med))
            if mod_med>=0.85 and mod_med<0.90:
                k = 1/((2*(1-mod_med))+((1-mod_med)**2)-((1-mod_med)**3))
            if mod_med>=0.90:
                k = 1/(2*(1-mod_med))
            resul_4 = f"Parameter Von Mises: <b>{k:.2f}</b><p>"
            self.par_k_t.setText(resul_4)

            # Desviación estandar angular
            sum_ang = 0
            for i in cd_selec.getFeatures():
                attrs=i.attributes()
                azim_feat = attrs[1]
                sum_ang += math.pi-abs(math.pi-abs((azim_feat*math.pi/180)-az_med))
            desv_ang = sum_ang/datos
            desv_ang = desv_ang*180/math.pi
            minutos, grados = math.modf(desv_ang)
            segundos, minutos = math.modf(minutos*60)
            segundos = (segundos*60)
            resul_5 = f"Angular standard Deviation:<br> <b>{grados:.0f}° {minutos:.0f}' {segundos:.2f}''</b><p>"
            self.des_ang_t.setText(resul_5)

            # Dispercion angular - desviacion angular media
            desv_ang_med = (180/math.pi)*(2*(1-mod_med))**0.5
            minutos, grados = math.modf(desv_ang_med)
            segundos, minutos = math.modf(minutos*60)
            segundos = (segundos*60)
            resul_6 = f"Angular mean Deviation (Batschelet, 1981):<br> <b>{grados:.0f}° {minutos:.0f}' {segundos:.2f}''</b><p>"
            self.des_angm_t.setText(resul_6)

            # Coeficiente de Asimetría (skewness o sesgo)
            skew = (mod_med2*math.sin(az_med2-(2*az_med)))/(1-mod_med)**(3/2)
            resul_7 = f"Skewness Coefficiennt (Asimetry or bias): <br> <b>{skew:.4f}''</b><p>"
            self.skew_t.setText(resul_7)
            
            # Medidas de Curtosis (o elevación)
            curt = ((mod_med2*math.cos(az_med2-(2*az_med)))-mod_med**4)/(1-mod_med)**2
            resul_8 = f"Kurtosis Coefficiennt (or elevation): <br> <b>{curt:.4f}''</b><p>"
            self.curt_t.setText(resul_8)

            # dispersión circular 
            disp_cir = (1-mod_med2)/(2*mod_med**2)
            resul_9 = f"Circular dispersal: <b>{disp_cir:.4f}''</b><p>"
            self.disp_cir_t.setText(resul_9)


            #Estadisticas horizontales
            #Calculo del Error medio Horizontal
            emh = sum_dist/datos
            resul_10 = f"Horizontal mean error: <b>{emh:.3f}</b><p>"
            self.emh_t.setText(resul_10)

            #Desviacion estandar horizontal
            sum_error2=0
            sum_este=0
            sum_norte=0
            if act_cde=="All":
                for j in range(len(lista_cde)):
                    cd_selec = project.mapLayersByName(lista_cde[j])[0]
                    for i in cd_selec.getFeatures():
                        attrs=i.attributes()
                        lon_feat = attrs[0]
                        azim_feat = attrs[1]
                        norte = (math.cos(azim_feat*math.pi/180))*lon_feat
                        este = (math.sin(azim_feat*math.pi/180))*lon_feat
                        sum_norte += norte
                        sum_este += este
            else:
                cd_selec = project.mapLayersByName(str(act_cde))[0]
                for i in cd_selec.getFeatures():
                    attrs=i.attributes()
                    lon_feat = attrs[0]
                    azim_feat = attrs[1]
                    norte = (math.cos(azim_feat*math.pi/180))*lon_feat
                    este = (math.sin(azim_feat*math.pi/180))*lon_feat
                    sum_norte += norte
                    sum_este += este
            norte_med=sum_norte/datos
            este_med=sum_este/datos

            sum_de2=0
            sum_dn2=0
            if act_cde=="All":
                for j in range(len(lista_cde)):
                    cd_selec = project.mapLayersByName(lista_cde[j])[0]
                    for i in cd_selec.getFeatures():
                        attrs=i.attributes()
                        lon_feat = attrs[0]
                        azim_feat = attrs[1]
                        dnorte = (((math.cos(azim_feat*math.pi/180))*lon_feat)-norte_med)**2
                        deste = (((math.sin(azim_feat*math.pi/180))*lon_feat)-este_med)**2
                        sum_dn2 += dnorte
                        sum_de2 += deste
            else:
                cd_selec = project.mapLayersByName(str(act_cde))[0]
                for i in cd_selec.getFeatures():
                    attrs=i.attributes()
                    lon_feat = attrs[0]
                    azim_feat = attrs[1]
                    dnorte = (((math.cos(azim_feat*math.pi/180))*lon_feat)-norte_med)**2
                    deste = (((math.sin(azim_feat*math.pi/180))*lon_feat)-este_med)**2
                    sum_dn2 += dnorte
                    sum_de2 += deste
            desv_sta_h=(((sum_de2+sum_dn2)/(datos-1))*0.5)**0.5
            resul_11 = f"Horizontal Standard Deviation: <br> <b>{desv_sta_h:.3f}</b><p>"
            self.dsh_t.setText(resul_11)

            #Potencial outlier 
                # Errores groseros circular
            m2 = (2.5055+(4.6052*math.log10(datos-1)))**0.5
            global m2_desv
            m2_desv = m2*desv_sta_h
            resul_12 = f"Potencial Outlier (>): <b>{m2_desv:.3f}</b><p>"
            self.pot_out_t.setText(resul_12)


            #Contar outliers
            sum_out=0
            if act_cde=="All":
                for j in range(len(lista_cde)):
                    cd_selec = project.mapLayersByName(lista_cde[j])[0]
                    for i in cd_selec.getFeatures():
                        attrs=i.attributes()
                        lon_feat = attrs[0]
                        if lon_feat>=m2_desv:
                            sum_out += 1
            else:
                cd_selec = project.mapLayersByName(str(act_cde))[0]
                for i in cd_selec.getFeatures():
                    attrs=i.attributes()
                    lon_feat = attrs[0]
                    if lon_feat>=m2_desv:
                        sum_out += 1

            resul_12 = f"Total Outlier: <b>{sum_out:.0f}</b><p>"
            self.tot_out_t.setText(resul_12)

            if sum_out>0:
                self.rem_out.setEnabled(True)

                #Dibujar un circulo de probabilidad de los outliers
                if self.den_gra_c.isChecked():
                    circ=m2_desv*(radius/max_total)
                    circle = QGraphicsEllipseItem(start.x() - circ, start.y() - circ, circ*2, circ*2)
                    circle.setPen(QPen(self.ringcolour))
                    self.circular.addItem(circle)

                    texts = QGraphicsSimpleTextItem("Outlier")
                    pos=((2**0.5)/2)*circ*1.1
                    texts.setPos(start.x() + pos,start.y() + pos)
                    deg_medcolour2 = QColor(197, 197, 197)
                    myPen2 = QPen(deg_medcolour2)
                    texts.setPen(myPen2)
                    self.circular.addItem(texts)

            else:
                self.rem_out.setEnabled(False)

        else:
            resul_1 = "Mean azimuth: <b>-° -' -''</b><p>"
            self.az_mean_t.setText(resul_1)
            resul_2 = "Mean module: <b>-</b><p>"
            self.mod_med_t.setText(resul_2)
            resul_3 = "Circular Variance: <b>-</b><p>"
            self.var_cir_t.setText(resul_3)
            resul_4 = "Circular Standard Deviation (Degree):<br> <b>-° -' -''</b><p>"
            self.des_cir_t.setText(resul_4)
            resul_4 = "Parameter Von Mises: <b>-</b><p>"
            self.par_k_t.setText(resul_4)
            resul_5 = "Angular standard Deviation:<br> <b>-° -' -''</b><p>"
            self.des_ang_t.setText(resul_5)
            resul_6 = "Angular mean Deviation (Batschelet, 1981):<br> <b>-° -' -''</b><p>"
            self.des_angm_t.setText(resul_6)
            resul_7 = "Skewness Coefficiennt (Asimetry or bias): <br> <b>-''</b><p>"
            self.skew_t.setText(resul_7)
            resul_8 = "Kurtosis Coefficiennt (or elevation): <br> <b>-''</b><p>"
            self.curt_t.setText(resul_8)
            resul_9 = "Circular dispersal: <b>-''</b><p>"
            self.disp_cir_t.setText(resul_9)
            resul_10 = "Horizontal mean error: <b>-</b><p>"
            self.emh_t.setText(resul_10)
            resul_11 = "Horizontal Standard Deviation: <br> <b>-</b><p>"
            self.dsh_t.setText(resul_11)
            resul_12 = "Potencial Outlier (>): <b>-</b><p>"
            self.pot_out_t.setText(resul_12)
            resul_12 = "Total Outlier: <b>-</b><p>"
            self.tot_out_t.setText(resul_12)


        #Textos en el grafico
        if self.cir_unit_c.isChecked():  
            title = QGraphicsSimpleTextItem("Unit circle graph")
            title.setPos(10,10)
            self.circular.addItem(title)
        
        if self.cir_dist_c.isChecked():  
            title = QGraphicsSimpleTextItem("Module and azimuth distribution graph")
            title.setPos(10,10)
            self.circular.addItem(title)

        if self.den_gra_c.isChecked():  
            title = QGraphicsSimpleTextItem("Density graph")
            title.setPos(10,10)
            self.circular.addItem(title)

        if self.cir_unit_c.isChecked() or self.cir_dist_c.isChecked():
            # Dibuja los sectores en el circulo unitario
            sect=self.section_a.value()
            deg_sec=360/sect
            self.deg_a.setText(str(round(deg_sec,0))+"°")

            for i in range(sect):
                ang=i*deg_sec
                pos_y = (math.cos(ang*math.pi/180))*(lon_max*1.05)
                pos_x = (math.sin(ang*math.pi/180))*(lon_max*1.05)
                linea_deg = QGraphicsLineItem(start.x(), start.y(), start.x()+pos_x, start.y()-pos_y)            
                deg_medcolour2 = QColor(197, 197, 197)
                myPen2 = QPen(deg_medcolour2)
                myPen2.setWidth(2)
                myPen2.setCapStyle(Qt.FlatCap)
                linea_deg.setPen(myPen2)
                self.circular.addItem(linea_deg)

            #Textos en el grafico
            text1 = QGraphicsSimpleTextItem("0°")
            text1.setPos((left + (width / 2))-3,(top + (height / 2))-radius*1.10)
            self.circular.addItem(text1)

            text2 = QGraphicsSimpleTextItem("90°")
            text2.setPos((left + (width / 2))+radius*1.05,(top + (height / 2))-8)
            self.circular.addItem(text2)

            text3 = QGraphicsSimpleTextItem("180°")
            text3.setPos((left + (width / 2)-8),(top + (height / 2))+radius*1.05)
            self.circular.addItem(text3)

            text4 = QGraphicsSimpleTextItem("270°")
            text4.setPos((left + (width / 2))-radius*1.10,(top + (height / 2))-8)
            self.circular.addItem(text4)

            #Texto en el circulo unitario
            for i in range(numrings):
                step = maxlength / numrings
                radius = step * (i + 1)
                if self.cir_unit_c.isChecked():
                    text=round((i + 1)/numrings,2)
                
                if self.cir_dist_c.isChecked():
                    text=round((i + 1)*lon_feat_max/numrings,2)

                text2 = QGraphicsSimpleTextItem(str(text))
                pos=((2**0.5)/2)*radius
                text2.setPos(start.x() + pos,start.y() + pos)
                self.circular.addItem(text2)

        if self.den_gra_c.isChecked():
            return()


        self.Bt1.setEnabled(True)

    def rest(self):
        self.Bt1.setEnabled(False)
        self.tabWidget.setTabEnabled(1,False)
        self.tabWidget.setTabEnabled(2,False)
        self.tabWidget.setCurrentIndex(0)

        self.Layer_E1.setCurrentIndex(-1)
        self.Layer_F1.setCurrentIndex(-1)
        self.Layer_E2.setCurrentIndex(-1)
        self.Layer_F2.setCurrentIndex(-1)
        self.Layer_E3.setCurrentIndex(-1)
        self.Layer_F3.setCurrentIndex(-1)        
        self.Layer_E4.setCurrentIndex(-1)
        self.Layer_F4.setCurrentIndex(-1)
        self.Layer_E5.setCurrentIndex(-1)
        self.Layer_F5.setCurrentIndex(-1)

        self.Layer_E2.setEnabled(False)
        self.Layer_F2.setEnabled(False)
        self.Layer_E3.setEnabled(False)
        self.Layer_F3.setEnabled(False)
        self.Layer_E4.setEnabled(False)
        self.Layer_F4.setEnabled(False)
        self.Layer_E5.setEnabled(False)
        self.Layer_F5.setEnabled(False)

        root2 = QgsProject.instance().layerTreeRoot()
        grupo2 = (root2.findGroup("Temporal"))

        for child in grupo2.children():
            capa=QgsProject.instance().mapLayersByName(child.name())
            QgsProject.instance().removeMapLayer(capa[0].id())

        nom_cde.clear()
        lista_cde.clear()

    def rem_outliers(self):
        act_cde = self.cde.currentText()
        if act_cde=="All":
            for j in range(len(lista_cde)):
                cd_selec = project.mapLayersByName(lista_cde[j])[0]
                for i in cd_selec.getFeatures():
                    attrs=i.attributes()
                    lon_feat = attrs[0]
                    if lon_feat>=m2_desv:
                        cd_selec.dataProvider().deleteFeatures([i.id()])
                        cd_selec.updateFeature(i)
        else:
            cd_selec = project.mapLayersByName(str(act_cde))[0]
            for i in cd_selec.getFeatures():
                attrs=i.attributes()
                lon_feat = attrs[0]
                if lon_feat>=m2_desv:
                    cd_selec.dataProvider().deleteFeatures([i.id()])
                    cd_selec.updateFeature(i)
        self.cir_unit()
